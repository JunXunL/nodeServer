<!--
 * @Descripttion: 
 * @Author: Irene.Z
 * @Date: 2021-02-19 17:00:30
 * @LastEditTime: 2021-06-16 17:02:51
 * @FilePath: \nodeServer\doc\token.md
-->
# Token
在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，tokens 是多用户下处理认证的最佳方式。
1. 用户通过用户名和密码向服务端发送请求
2. 服务端通过验证，生成一个token发送给客户端
3. 客户端保存token，发送请求时带上token
4. 服务器通过验证，返回数据

## token的优势
1. 无状态、可扩展
在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上。
如果我们将已验证的用户的信息保存在Session中，则每次请求都需要用户向已验证的服务器发送验证信息(称为Session亲和性)。用户量大时，可能会造成一些拥堵。
使用tokens之后这些问题都迎刃而解。
2. 支持移动设备
CORS(跨域资源共享)对应用程序和服务进行扩展的时候，需要介入各种各种的设备和应用程序。
只要用户有一个通过了验证的token，数据和资源就能够在任何域上被请求到。
3. 跨程序调用
4. 安全
请求中发送token而不再是发送Cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。
token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。

*大部分的 API 和 Web 应用都使用 tokens。例如 Facebook， Twitter， Google+， GitHub等。*
*比如说，（用户小F）已经登录了系统，【网站A】给他发一个令牌(token)，里边包含了（用户小F）的 user id，下一次（用户小F）再次通过 Http请求 访问【网站A】的时候，把这个 token 通过Http header 带过来就可以了。带过来之后就可以通过user id 查到（用户小F）的权限 和 （用户小F）相关各种数据返回了。*

## 安全性
*对数据做一个签名， 比如说 HMAC-SHA256 算法，加上一个只有开发阶段中【创造者】才知道的密钥，对数据做一个签名，把这个 签名 和数据一起作为 token，由于密钥除了【创造者】，别人都不知道，就无法伪造token了。*
```
Header | {"userID", "u123456"}
    \       /
     \     /
      \   /
       \ /
        |
  HMAC-SHA256算法  <---  密钥
        |
        |
      签名
```
*这个 token 我不保存，当用户把这个 自己的token 给我发过来的时候，我再用同样的HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名，和 token 中的签名做个比较，如果相同，我就知道用户已经登录过了，并且可以直接取到该用户的的user id ，如果不相同，数据部分肯定被人篡改过，就证明这个人没有登录*

```
Header | {"userID", "u123456"} | 签名
    \       /                     |
     \     /                      |
      \   /                       |
       \ /                        |
        |                         |
  HMAC-SHA256算法  <---  密钥      |
        |                         |
        |                         |
      签名 <------判断是否相同-----|
```
*这样还是维持了 http 无状态情况，机器集群现在可以轻松地做水平扩展，用户访问量增大，直接加机器就行。*


# Cookie
cookie和session的区别就是，cookie保存在前端，而session保存在后端，但是两者都是后端生成。具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的。cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session， session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie

单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie。

可以将登陆信息等重要信息存放为session。

## 使用cookie的缺点
如果浏览器使用的是 cookie，那么所有的数据都保存在浏览器端，
* cookie可以被用户禁止
* cookie不安全(对于敏感数据，需要加密)
* cookie只能保存少量的数据(大约是4k)，cookie的数量也有限制(大约是几百个)，不同浏览器设置不一样，反正都不多
* cookie只能保存字符串
* 对服务器压力小

## 使用session的缺点
* 一般是寄生在Cookie下的，当Cookie被禁止，Session也被禁止
* 当然可以通过url重写来摆脱cookie
* 当用户访问量很大时，对服务器压力大

我们现在知道session是将用户信息储存在服务器上面，如果访问服务器的用户越来越多，那么服务器上面的session也越来越多，session会对服务器造成压力，影响服务器的负载。如果Session内容过于复杂，当大量客户访问服务器时还可能会导致内存溢出。

用户信息丢失，或者说用户访问的不是这台服务器的情况下，就会出现数据库丢失。


# session
*服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。*

现在的在线购物网站，需要登录的网站等等，马上就面临一个问题，那就是要管理会话，必须记住哪些人登录系统， 哪些人往自己的购物车中放商品， 也就是说我必须把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，所以想出的办法就是给大家发一个会话标识(session id), 说白了就是一个随机的字串，每个人收到的都不一样， 每次大家向我发起HTTP请求的时候，把这个字符串给一并捎过来， 这样我就能区分开谁是谁了，每个人只需要保存自己的session id，而服务器要保存所有人的session id ！如果访问服务器多了， 就得由成千上万，甚至几十万个。

这对服务器说是一个巨大的开销，严重的限制了服务器扩展能力，比如说我用两个机器组成了一个集群，小F通过机器A登录了系统，那session id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的 session id啊。

有时候会采用： session sticky ， 就是让小F的请求一直粘连在机器A上， 但是这也不管用， 要是机器A挂掉了， 还得转到机器B去。

那只好做session 的复制了， 把session id 在两个机器之间搬来搬去。
```
             负载均衡
               /  \
              /    \
             /      \
            /        \
           /          \
  |-------/------------\-------|
  | session  <-复制->  session |
  | 服务器A            服务器B  |
  |----------------------------|
  |          Cluster           |
```

后来有个叫Memcached的支了招：把session id 集中存储到一个地方， 所有的机器都来访问这个地方的数据， 这样一来，就不用复制了， 但是增加了单点失败的可能性， 要是那个负责session 的机器挂了， 所有人都得重新登录一遍。
```
             负载均衡
               /  \
              /    \
             /      \
            /        \
           /          \
  |-------/------------\--------|
  | 服务器A  (Cluster)  服务器B  |
  |--------\-----------/--------|
            \         /
             \       /
              \     /
             session存储
```
也尝试把这个单点的机器也搞出集群，增加可靠性， 但不管如何， 这小小的session 对后台来说是一个沉重的负担。


# 基于服务器验证方式暴露的一些问题
* Seesion：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。
* 可扩展性：在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题。
* CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。
* CSRF(跨站请求伪造)：用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。